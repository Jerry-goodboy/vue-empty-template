// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.7/esri/copyright.txt for details.
//>>built
require({cache:{"url:esri/views/3d/webgl-engine/materials/DefaultMaterial.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\r\n\r\n\x3csnippets\x3e\r\n\r\n\x3csnippet name\x3d"calculateVerticalOffset"\x3e\x3c![CDATA[\r\n  $viewingMode\r\n\r\n#ifdef VERTICAL_OFFSET\r\n  // [ verticalOffsetPerDistance, minWorldLength, maxWorldLength ]\r\n  uniform vec4 verticalOffset;\r\n\r\n#ifdef SCREEN_SIZE_PERSPECTIVE\r\n\r\n  uniform vec4 screenSizePerspectiveAlignment;\r\n\r\n  $screenSizePerspective\r\n\r\n#endif\r\n\r\n  vec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {\r\n    float viewDistance \x3d length((view * vec4(worldPos, 1)).xyz);\r\n    float verticalOffsetOffsetDistance \x3d verticalOffset.x * viewDistance;\r\n\r\n#ifdef VIEWING_MODE_GLOBAL\r\n    vec3 worldNormal \x3d normalize(worldPos + localOrigin);\r\n#else\r\n    vec3 worldNormal \x3d vec3(0, 0, 1);\r\n#endif\r\n\r\n#ifdef SCREEN_SIZE_PERSPECTIVE\r\n    float cosAngle \x3d dot(worldNormal, normalize(worldPos - camPos));\r\n\r\n    float verticalOffsetScreenHeight \x3d screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);\r\n#else\r\n    float verticalOffsetScreenHeight \x3d verticalOffset.x;\r\n#endif\r\n\r\n    // Screen sized offset in world space, used for example for line callouts\r\n    float worldOffset \x3d clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);\r\n\r\n    return worldNormal * worldOffset;\r\n  }\r\n#endif\r\n]]\x3e\r\n\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsPhongSrc"\x3e\x3c![CDATA[\r\n\tuniform mat4 proj;\r\n\tuniform mat4 view;\r\n  uniform vec3 camPos;\r\n\r\n\tuniform vec3 localOrigin;\r\n\r\n#ifdef INSTANCED\r\n    attribute mat4 model;\r\n    attribute mat4 modelNormal;\r\n#else\r\n\tuniform mat4 model;\r\n\tuniform mat4 modelNormal;\r\n#endif\r\n#ifdef INSTANCEDCOLOR\r\n\tattribute vec4 instanceColor;\r\n#endif\r\n\tattribute vec3 $position;\r\n#ifdef COMPRESSED_NORMALS\r\n  attribute vec2 $normalCompressed;\r\n#else\r\n  attribute vec3 $normal;\r\n#endif\r\n\tvarying vec3 vpos;\r\n\tvarying vec3 vnormal;\r\n\r\n#ifdef COMPONENTCOLORS\r\n  uniform sampler2D uComponentColorTex;\r\n  uniform vec2 uComponentColorTexInvDim;\r\n\r\n  attribute float $componentIndex;\r\n\r\n  vec4 readComponentColor() {\r\n    float normalizedIndex \x3d ($componentIndex + 0.5) * uComponentColorTexInvDim.x;\r\n    vec2 indexCoord \x3d vec2(\r\n      mod(normalizedIndex, 1.0),\r\n      (floor(normalizedIndex) + 0.5) * uComponentColorTexInvDim.y\r\n    );\r\n    return texture2D(uComponentColorTex, indexCoord);\r\n  }\r\n#endif\r\n\r\n#ifdef RECEIVE_SHADOWS\r\n\tvarying float linearDepth;\r\n#endif\r\n\r\n#ifdef VERTEXCOLORS\r\n\tattribute vec4 $color;\r\n#endif\r\n\r\n#ifdef SYMBOLVERTEXCOLORS\r\n  attribute vec4 $symbolColor;\r\n#endif\r\n\r\n#if defined(VV_SIZE) || defined(VV_COLOR)\r\n\tattribute vec4 instanceFeatureAttribute;\r\n#endif\r\n\r\n$vvUniforms\r\n\r\n#if defined(VERTEXCOLORS)\r\n\tvarying vec4 vcolor;\r\n#endif\r\n\r\n  // Workaround for https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/13452\r\n  // We pass the externalColor uniform from VS to FS through the vcolorExt varying because\r\n  // there is a driver bug for Intel Integrated Graphics which led to rendering artifacts\r\n  // since the introduction of https://devtopia.esri.com/WebGIS/arcgis-js-api/pull/12673\r\n  // This should be further cleaned up later with through the following issue:\r\n  // https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/12763\r\n\tuniform vec4 externalColor;\r\n\tvarying vec4 vcolorExt;\r\n\r\n#if defined(SYMBOLVERTEXCOLORS) || defined(COMPONENTCOLORS)\r\n\tvarying mediump float colorMixMode; // varying int is not supported in WebGL\r\n#endif\r\n\r\n\t$vvFunctions\r\n\r\n\t$colorMixMode\r\n\r\n  $calculateVerticalOffset\r\n\r\n  $decodeNormal\r\n\r\n\tvoid main(void) {\r\n\r\n#ifdef VV_CUSTOM_MODEL_MATRIX\r\n\r\n\t\tvpos \x3d (model * vvTransformPosition($position, instanceFeatureAttribute)).xyz;\r\n\r\n#ifdef COMPRESSED_NORMALS\r\n    vnormal \x3d normalize((modelNormal * vvTransformNormal(decodeNormal($normalCompressed), instanceFeatureAttribute)).xyz);\r\n#else\r\n    vnormal \x3d normalize((modelNormal * vvTransformNormal($normal, instanceFeatureAttribute)).xyz);\r\n#endif\r\n\r\n#ifdef VERTICAL_OFFSET\r\n\t\tvec3 centerPos \x3d (model * vvTransformPosition(vec3(0, 0, 0), instanceFeatureAttribute)).xyz;\r\n#endif\r\n\r\n#else /* VV_CUSTOM_MODEL_MATRIX */\r\n\r\n\t\tvpos \x3d (model * vec4($position, 1.0)).xyz;\r\n#ifdef COMPRESSED_NORMALS\r\n    vnormal \x3d normalize((modelNormal * vec4(decodeNormal($normalCompressed), 1.0)).xyz);\r\n#else\r\n    vnormal \x3d normalize((modelNormal * vec4($normal, 1.0)).xyz);\r\n#endif\r\n\r\n#ifdef VERTICAL_OFFSET\r\n\t\tvec3 centerPos \x3d (model * vec4(vec3(0, 0, 0), 1.0)).xyz;\r\n#endif\r\n\r\n#endif /* VV_CUSTOM_MODEL_MATRIX */\r\n\r\n#ifdef VERTICAL_OFFSET\r\n    vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\r\n#endif\r\n\r\n\t\tgl_Position \x3d proj * view * vec4(vpos, 1.0);\r\n\r\n#ifdef RECEIVE_SHADOWS\r\n\t\t// Shadowmap\'s cascading index used to be based on \'1.0 / gl_FragCoord.w\'\r\n\t\t// (i.e. the perspective interpolation of \'gl_Position.w\'). Precision\r\n\t\t// issues on iPad/iPhone with the \'w\' component require the depth to be\r\n\t\t// passed as varying to properly drive the cascading shadow map index.\r\n\t\tlinearDepth \x3d gl_Position.w;\r\n#endif\r\n\r\n#ifdef VERTEXCOLORS\r\n\t\tvcolor \x3d $color * 0.003921568627451; // \x3d 1/255\r\n#endif\r\n\r\n\t\tvcolorExt \x3d externalColor;\r\n\r\n#ifdef INSTANCEDCOLOR\r\n\t\tvcolorExt *\x3d instanceColor;\r\n#endif\r\n#ifdef VV_COLOR\r\n\t\tvcolorExt *\x3d vvGetColor(instanceFeatureAttribute, vvColorValues, vvColorColors);\r\n#endif\r\n#ifdef SYMBOLVERTEXCOLORS\r\n    int symbolColorMixMode;\r\n    vcolorExt *\x3d decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451; // \x3d 1/255;\r\n    colorMixMode \x3d float(symbolColorMixMode) + 0.5; // add 0.5 to avoid interpolation artifacts\r\n#endif\r\n#ifdef COMPONENTCOLORS\r\n    int symbolColorMixMode;\r\n    vcolorExt *\x3d decodeSymbolColor(readComponentColor() * 255.0, symbolColorMixMode) * 0.003921568627451; // \x3d 1/255;\r\n    colorMixMode \x3d float(symbolColorMixMode) + 0.5; // add 0.5 to avoid interpolation artifacts\r\n#endif\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsPhongSrc"\x3e\x3c![CDATA[\r\n  $fsprecisionf\r\n\r\n\tuniform vec3 camPos;\r\n\tuniform vec3 localOrigin;\r\n\r\n\t$sceneLightingDefinitions\r\n\t$sceneLightingAdditionalLightGlobal\r\n\r\n\t// material parameters\r\n\t//////////////////////////////////////////\r\n\tuniform vec3 ambient;\r\n\tuniform vec3 diffuse;\r\n\tuniform vec3 specular;\r\n\tuniform float opacity;\r\n\tuniform float layerOpacity;\r\n\r\n#if defined(SYMBOLVERTEXCOLORS) || defined(COMPONENTCOLORS)\r\n\tvarying mediump float colorMixMode; // varying int is not supported in WebGL\r\n#else\r\n  uniform int colorMixMode;\r\n#endif\r\n\r\n#ifdef RECEIVE_SHADOWS\r\n\tuniform sampler2D depthTex;\r\n\tuniform int shadowMapNum;\r\n\tuniform vec4 shadowMapDistance;\r\n\tuniform mat4 shadowMapMatrix[4];\r\n\tuniform float depthHalfPixelSz;\r\n#endif\r\n\r\n#ifdef RECEIVE_SSAO\r\n\tuniform sampler2D ssaoTex;\r\n\tuniform vec4 viewportPixelSz;\r\n#endif\r\n\r\n\r\n\tvarying vec3 vpos;\r\n\tvarying vec3 vnormal;\r\n#if defined(VERTEXCOLORS)\r\n\tvarying vec4 vcolor;\r\n#endif\r\n\tvarying vec4 vcolorExt;\r\n\r\n#ifdef RECEIVE_SHADOWS\r\n\tvarying float linearDepth;\r\n\t$evalShadow\r\n#endif\r\n\r\n\t$colorMixMode\r\n\r\n\tvoid main() {\r\n\t\tvec3 viewDir \x3d normalize(vpos - camPos);\r\n\r\n\t\t$computeNormal\r\n\r\n\t\tvec3 reflDir \x3d normalize(reflect(viewDir, normal));\r\n\r\n\t\t// compute ssao\r\n\t\t#ifdef RECEIVE_SSAO\r\n\t\t\t\tfloat ssao \x3d texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\r\n\t\t\t\tssao \x3d viewportPixelSz.z \x3c 0.0 ? 1.0 : ssao;\r\n\t\t#else\r\n\t\t\t\tfloat ssao \x3d 1.0;\r\n\t\t#endif\r\n\r\n\t\t// At global scale we create some additional ambient light based on the main light to simulate global illumination\r\n\t\tfloat additionalAmbientScale;\r\n\t\tvec3 additionalLight \x3d sceneLightingAdditionalLightGlobal(vpos + localOrigin, ssao, additionalAmbientScale);\r\n\r\n\t\t// compute shadowing\r\n\t\tfloat shadow \x3d 0.0;\r\n\t\t#ifdef RECEIVE_SHADOWS\r\n\t\t\tshadow \x3d evalShadow(vpos, linearDepth, depthTex, shadowMapNum, shadowMapDistance, shadowMapMatrix, depthHalfPixelSz);\r\n\t\t#elif defined(VIEWING_MODE_GLOBAL)\r\n\t\t\t// at global scale (and in global scenes) we fall back to this approximation\r\n\t\t\t// to shadow objects on the dark side of the earth\r\n\t\t\tshadow \x3d lightingGlobalFactor * (1.0 - additionalAmbientScale);\r\n\t\t#endif\r\n\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3c!-- Keep is synchronized with the logic in Material.js:isVisible --\x3e\r\n\x3csnippet name\x3d"externalColorMix"\x3e\x3c![CDATA[\r\n\tvec3 matColor \x3d max(ambient, diffuse); // combine the old material parameters into a single one\r\n\t#if defined(VERTEXCOLORS)\r\n\t\t\t// Internal colors: varying vcolor + uniform ambient/diffuse, external colors: varying vcolorExt\r\n\t\t\tvec3 albedo_ \x3d mixExternalColor(vcolor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\r\n\t\t\tfloat opacity_ \x3d layerOpacity * mixExternalOpacity(vcolor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));\r\n\t#else\r\n\t\t\t// Internal colors: uniform ambient/diffuse, external colors: varying vcolorExt\r\n\t\t\tvec3 albedo_ \x3d mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\r\n\t\t\tfloat opacity_ \x3d layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));\r\n\t#endif\r\n\talbedo_+\x3d 0.25 * specular; // don\'t completely ignore specular for now\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsPhong"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n\t$vsPhongSrc\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsPhong"\x3e\x3c![CDATA[\r\n\t\t$fsprecisionf\r\n\r\n\t\t$fsPhongSrc\r\n\r\n\t\tvec4 texColor \x3d vec4(1,1,1,1);\r\n\t\t$externalColorMix\r\n\r\n\t\tif (opacity_ \x3c 0.001) {\r\n\t\t\tdiscard;\r\n\t\t}\r\n\r\n\t\tvec3 shadedColor \x3d evaluateSceneLighting(normal, albedo_, shadow, 1.0 - ssao, additionalLight);\r\n\r\n\t\tgl_FragColor \x3d vec4(shadedColor, opacity_);\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsPhongTextured"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n\tattribute vec2 $uv0;\r\n\tvarying vec2 vtc;\r\n\t$vsPhongSrc\r\n#ifndef FLIPV\r\n\t\tvtc \x3d $uv0;\r\n#else\r\n\t\tvtc \x3d vec2($uv0.x, 1.0-$uv0.y);\r\n#endif\r\n\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsPhongTextured"\x3e\x3c![CDATA[\r\n\t$fsprecisionf\r\n\r\n\tuniform sampler2D tex;\r\n\tvarying vec2 vtc;\r\n\r\n\t$fsPhongSrc\r\n\r\n\t\t// read texture color\r\n\t\tvec4 texColor \x3d texture2D(tex, vtc);\r\n\t\tif (texColor.a \x3c .33) discard;\r\n\r\n\t\t$externalColorMix\r\n\r\n\t\tif (opacity_ \x3c 0.001) {\r\n\t\t\tdiscard;\r\n\t\t}\r\n\r\n\t\tvec3 shadedColor \x3d evaluateSceneLighting(normal, albedo_, shadow, 1.0 - ssao, additionalLight);\r\n\r\n\t\tgl_FragColor \x3d vec4(shadedColor, opacity_);\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsPhongAtlasTextured"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n\tattribute vec4 $uv0;\r\n\tattribute vec4 $region;\r\n\tvarying vec2 vtc;\r\n\tvarying vec4 regionV;\r\n\t$vsPhongSrc\r\n#ifndef FLIPV\r\n\t\tvtc \x3d $uv0.xy;\r\n#else\r\n\t\tvtc \x3d vec2($uv0.x, 1.0-$uv0.y);\r\n#endif\r\n\t\tregionV \x3d $region/65535.0;\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsPhongAtlasTextured"\x3e\x3c![CDATA[\r\n\t$fsprecisionf\r\n\r\n\tuniform sampler2D tex;\r\n\tuniform vec2 texSize;\r\n\tvarying vec2 vtc;\r\n\tvarying vec4 regionV;\r\n\r\n\tfloat calcMipMapLevel(const vec2 ddx, const vec2 ddy) {\r\n\t\t// from:\r\n\t\t//   - OpenGLES Common Profile Specification Version 2.0.25, Section 3.7.7 - Texture Minification\r\n\t\t//   - https://www.opengl.org/discussion_boards/showthread.php/171485-Texture-LOD-calculation-(useful-for-atlasing)\r\n\t\t//   - http://www.linedef.com/virtual-texture-demo.html\r\n\t\tfloat deltaMaxSqr \x3d max(dot(ddx, ddx), dot(ddy, ddy));\r\n\t\treturn max(0.5 * log2(deltaMaxSqr), 0.0);\r\n\t}\r\n\r\n\t$fsPhongSrc\r\n\r\n\t\tvec2 uv \x3d vtc;\r\n\t\tuv \x3d fract(uv);\r\n\t\t//[umin, vmin, umax, vmax]\r\n\r\n\t\tvec2 atlasScale \x3d regionV.zw - regionV.xy;\r\n\t\tuv \x3d uv.xy * atlasScale + regionV.xy;\r\n\r\n\t\tvec4 texColor;\r\n\t\t#ifdef GL_OES_standard_derivatives\r\n\t\t\t#extension GL_OES_standard_derivatives : enable\r\n\r\n\t\t\t// calculate derivative of continuous texture coordinate\r\n\t\t\t// to avoid mipmapping artifacts caused by manual wrapping in shader\r\n\t\t\tvec2 dUVdx \x3d dFdx(vtc) * atlasScale;\r\n\t\t\tvec2 dUVdy \x3d dFdy(vtc) * atlasScale;\r\n\r\n\t\t\t#ifdef GL_EXT_shader_texture_lod\r\n\t\t\t\t#extension GL_EXT_shader_texture_lod : enable\r\n\r\n\t\t\t\t// workaround for artifacts in Windows 10 using Intel HD Graphics 4000 series\r\n\t\t\t\t// see: https://devtopia.esri.com/Zurich-R-D-Center/arcgis-js-api-canvas3d-issues/issues/768\r\n\t\t\t\tconst float epsilon \x3d 1.0E-32;\r\n\t\t\t\tfloat zeroUVShift \x3d uv.x \x3d\x3d 0.0 \x26\x26 uv.y \x3d\x3d 0.0 ? epsilon : 0.0;\r\n\r\n\t\t\t\ttexColor \x3d texture2DGradEXT(tex, uv + zeroUVShift, dUVdx, dUVdy);\r\n\t\t\t#else\r\n\t\t\t\t// use bias to compensate for difference in automatic vs desired mipmap level\r\n\t\t\t\tvec2 dUVdxAuto \x3d dFdx(uv);\r\n\t\t\t\tvec2 dUVdyAuto \x3d dFdy(uv);\r\n\t\t\t\tfloat mipMapLevel \x3d calcMipMapLevel(dUVdx * texSize, dUVdy * texSize);\r\n\t\t\t\tfloat autoMipMapLevel \x3d calcMipMapLevel(dUVdxAuto * texSize, dUVdyAuto * texSize);\r\n\t\t\t\ttexColor \x3d texture2D(tex, uv, mipMapLevel - autoMipMapLevel);\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\ttexColor \x3d texture2D(tex, uv);\r\n\t\t#endif\r\n\r\n\t\tif (texColor.a \x3c .33) discard;\r\n\r\n\t\t$externalColorMix\r\n\r\n\t\tif (opacity_ \x3c 0.001) {\r\n\t\t\tdiscard;\r\n\t\t}\r\n\r\n\t\tvec3 shadedColor \x3d evaluateSceneLighting(normal, albedo_, shadow, 1.0 - ssao, additionalLight);\r\n\t\tgl_FragColor \x3d vec4(shadedColor, opacity_);\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsDepthSrc"\x3e\x3c![CDATA[\r\n\tuniform mat4 proj;\r\n\tuniform mat4 view;\r\n  uniform vec3 camPos;\r\n  uniform vec3 localOrigin;\r\n\r\n#ifdef INSTANCED\r\n\tattribute mat4 model;\r\n  attribute mat4 modelNormal;\r\n#else\r\n\tuniform mat4 model;\r\n  uniform mat4 modelNormal;\r\n#endif\r\n\tuniform vec2 nearFar;\r\n\tattribute vec3 $position;\r\n\tvarying float depth;\r\n\r\n\t$vvUniforms\r\n#if defined(VV_CUSTOM_MODEL_MATRIX)\r\n\tattribute vec4 instanceFeatureAttribute;\r\n#endif\r\n\t$vvFunctions\r\n\r\n  $calculateVerticalOffset\r\n\r\n\tvoid main(void) {\r\n\r\n#ifdef VV_CUSTOM_MODEL_MATRIX\r\n\r\n    vec3 vpos \x3d (model * vvTransformPosition($position, instanceFeatureAttribute)).xyz;\r\n\r\n#ifdef VERTICAL_OFFSET\r\n    vec3 centerPos \x3d (model * vvTransformPosition(vec3(0, 0, 0), instanceFeatureAttribute)).xyz;\r\n#endif\r\n\r\n#else /* VV_CUSTOM_MODEL_MATRIX */\r\n\r\n\t\tvec3 vpos \x3d (model * vec4($position, 1.0)).xyz;\r\n\r\n#ifdef VERTICAL_OFFSET\r\n\t\tvec3 centerPos \x3d (model * vec4(vec3(0, 0, 0), 1.0)).xyz;\r\n#endif\r\n\r\n#endif /* VV_CUSTOM_MODEL_MATRIX */\r\n\r\n#ifdef VERTICAL_OFFSET\r\n    vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\r\n#endif\r\n\r\n    vec4 eye \x3d view * vec4(vpos, 1);\r\n\r\n\t\tgl_Position \x3d proj * eye;\r\n\t\tdepth \x3d (-eye.z - nearFar[0]) / (nearFar[1] - nearFar[0]) ;\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsDepth"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n\t$vsDepthSrc\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsDepthTextured"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n\tattribute vec2 $uv0;\r\n\tvarying vec2 vtc;\r\n\t$vsDepthSrc\r\n#ifndef FLIPV\r\n        vtc \x3d $uv0;\r\n#else\r\n        vtc \x3d vec2($uv0.x, 1.0-$uv0.y);\r\n#endif\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsNormalSrc"\x3e\x3c![CDATA[\r\n\tuniform mat4 proj;\r\n\tuniform mat4 view;\r\n  uniform vec3 camPos;\r\n  uniform vec3 localOrigin;\r\n\r\n#ifdef INSTANCED\r\n\tattribute mat4 model;\r\n\tattribute mat4 modelNormal;\r\n#else\r\n\tuniform mat4 model;\r\n\tuniform mat4 modelNormal;\r\n#endif\r\n\tuniform mat4 viewNormal;\r\n\tattribute vec3 $position;\r\n#ifdef COMPRESSED_NORMALS\r\n  attribute vec2 $normalCompressed;\r\n#else\r\n  attribute vec3 $normal;\r\n#endif\r\n\tvarying vec3 vnormal;\r\n\r\n\t$vvUniforms\r\n#if defined(VV_CUSTOM_MODEL_MATRIX)\r\n\tattribute vec4 instanceFeatureAttribute;\r\n#endif\r\n\t$vvFunctions\r\n\r\n  $calculateVerticalOffset\r\n\r\n  $decodeNormal\r\n\r\n\tvoid main(void) {\r\n\r\n#ifdef VV_CUSTOM_MODEL_MATRIX\r\n\r\n    vec3 vpos \x3d (model * vvTransformPosition($position, instanceFeatureAttribute)).xyz;\r\n#ifdef COMPRESSED_NORMALS\r\n    vnormal \x3d normalize((viewNormal * modelNormal * vvTransformNormal(decodeNormal($normalCompressed), instanceFeatureAttribute)).xyz);\r\n#else\r\n\t\tvnormal \x3d normalize((viewNormal * modelNormal * vvTransformNormal($normal, instanceFeatureAttribute)).xyz);\r\n#endif\r\n\r\n#ifdef VERTICAL_OFFSET\r\n    vec3 centerPos \x3d (model * vvTransformPosition(vec3(0, 0, 0), instanceFeatureAttribute)).xyz;\r\n#endif\r\n\r\n#else /* VV_CUSTOM_MODEL_MATRIX */\r\n\t\tvec3 vpos \x3d (model * vec4($position, 1.0)).xyz;\r\n#ifdef COMPRESSED_NORMALS\r\n    vnormal \x3d normalize((viewNormal * modelNormal * vec4(decodeNormal($normalCompressed), 1.0)).xyz);\r\n#else\r\n\t\tvnormal \x3d normalize((viewNormal * modelNormal * vec4($normal, 1.0)).xyz);\r\n#endif\r\n\r\n#ifdef VERTICAL_OFFSET\r\n    vec3 centerPos \x3d (model * vec4(vec3(0, 0, 0), 1.0)).xyz;\r\n#endif\r\n\r\n#endif /* VV_CUSTOM_MODEL_MATRIX */\r\n\r\n#ifdef VERTICAL_OFFSET\r\n    vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\r\n#endif\r\n\r\n    gl_Position \x3d proj * view * vec4(vpos, 1);\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsNormal"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n\t$vsNormalSrc\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsNormalTextured"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n\tattribute vec2 $uv0;\r\n\tvarying vec2 vtc;\r\n\t$vsNormalSrc\r\n#ifndef FLIPV\r\n\t\tvtc \x3d $uv0;\r\n#else\r\n\t\tvtc \x3d vec2($uv0.x, 1.0-$uv0.y);\r\n#endif\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsHighlightSrc"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n\tuniform mat4 proj;\r\n\tuniform mat4 view;\r\n  uniform vec3 camPos;\r\n  uniform vec3 localOrigin;\r\n\r\n#ifdef INSTANCED\r\n\tattribute mat4 model;\r\n  attribute mat4 modelNormal;\r\n#else\r\n\tuniform mat4 model;\r\n  uniform mat4 modelNormal;\r\n#endif\r\n\tattribute vec3 $position;\r\n\r\n\t$vvUniforms\r\n#if defined(VV_CUSTOM_MODEL_MATRIX)\r\n\tattribute vec4 instanceFeatureAttribute;\r\n#endif\r\n\t$vvFunctions\r\n\r\n  $calculateVerticalOffset\r\n\r\n\tvoid main(void) {\r\n\r\n#ifdef VV_CUSTOM_MODEL_MATRIX\r\n\r\n    vec3 vpos \x3d (model * vvTransformPosition($position, instanceFeatureAttribute)).xyz;\r\n\r\n#ifdef VERTICAL_OFFSET\r\n    vec3 centerPos \x3d (model * vvTransformPosition(vec3(0, 0, 0), instanceFeatureAttribute)).xyz;\r\n#endif\r\n\r\n#else /* VV_CUSTOM_MODEL_MATRIX */\r\n\r\n    vec3 vpos \x3d (model * vec4($position, 1.0)).xyz;\r\n\r\n#ifdef VERTICAL_OFFSET\r\n    vec3 centerPos \x3d (model * vec4(vec3(0, 0, 0), 1.0)).xyz;\r\n#endif\r\n\r\n#endif /* VV_CUSTOM_MODEL_MATRIX */\r\n\r\n#ifdef VERTICAL_OFFSET\r\n    vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\r\n#endif\r\n\r\n\t\tgl_Position \x3d proj * view * vec4(vpos, 1);\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsHighlight"\x3e\x3c![CDATA[\r\n\t$vsHighlightSrc\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsHighlightTextured"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n\tattribute vec2 $uv0;\r\n\tvarying vec2 vtc;\r\n\t$vsHighlightSrc\r\n#ifndef FLIPV\r\n\t\tvtc \x3d $uv0;\r\n#else\r\n\t\tvtc \x3d vec2($uv0.x, 1.0-$uv0.y);\r\n#endif\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsDepthSrc"\x3e\x3c![CDATA[\r\n  $fsprecisionf\r\n\tvarying float depth;\r\n\r\n\tvoid main() {\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsDepth"\x3e\x3c![CDATA[\r\n\t$fsprecisionf\r\n\r\n\t$calcFragDepth\r\n\t$float2rgba\r\n\t$fsDepthSrc\r\n#ifndef BIAS_SHADOWMAP\r\n\t\tgl_FragColor \x3d float2rgba(depth);\r\n#else\r\n\t\tgl_FragColor \x3d float2rgba(calcFragDepth(depth));\r\n#endif\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsDepthTextured"\x3e\x3c![CDATA[\r\n\t$fsprecisionf\r\n\r\n\tuniform sampler2D tex;\r\n\tvarying vec2 vtc;\r\n\t$calcFragDepth\r\n\t$float2rgba\r\n\r\n\t$fsDepthSrc\r\n\t\tif (texture2D(tex, vtc).a \x3c .33) discard;\r\n#ifndef BIAS_SHADOWMAP\r\n\t\tgl_FragColor \x3d float2rgba(depth);\r\n#else\r\n\t\tgl_FragColor \x3d float2rgba(calcFragDepth(depth));\r\n#endif\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsNormal"\x3e\x3c![CDATA[\r\n\t$fsprecisionf\r\n\r\n\tvarying vec3 vnormal;\r\n\tvoid main() {\r\n\t\tvec3 normal \x3d normalize(vnormal);\r\n\t\tif (gl_FrontFacing \x3d\x3d false) normal \x3d -normal;\r\n\r\n#ifndef ALPHA_ZERO\r\n\t\tgl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 1.0);\r\n#else\r\n\t\tgl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 0.0);\r\n#endif\r\n\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsNormalTextured"\x3e\x3c![CDATA[\r\n\t$fsprecisionf\r\n\r\n\tvarying vec3 vnormal;\r\n\tvarying vec2 vtc;\r\n\tuniform sampler2D tex;\r\n\tvoid main() {\r\n\t\tif (texture2D(tex, vtc).a \x3c .33) discard;\r\n\t\tvec3 normal \x3d normalize(vnormal);\r\n\t\tif (gl_FrontFacing \x3d\x3d false) normal \x3d -normal;\r\n#ifndef ALPHA_ZERO\r\n\t\tgl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 1.0);\r\n#else\r\n\t\tgl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 0.0);\r\n#endif\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsHighlight"\x3e\x3c![CDATA[\r\n\t$fsprecisionf\r\n  uniform sampler2D depthTex;\r\n  uniform vec4 highlightViewportPixelSz;\r\n\r\n\tvoid main() {\r\n\t\t$highlightWrite\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsHighlightTextured"\x3e\x3c![CDATA[\r\n\t$fsprecisionf\r\n\r\n\tvarying vec2 vtc;\r\n\tuniform sampler2D tex;\r\n  uniform sampler2D depthTex;\r\n  uniform vec4 highlightViewportPixelSz;\r\n\r\n\tvoid main() {\r\n\t\tif (texture2D(tex, vtc).a \x3c .33) discard;\r\n\r\n\t\t$highlightWrite\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3c/snippets\x3e\r\n'}});
define("require exports ../../../../core/tsSupport/extendsHelper dojo/text!./DefaultMaterial.xml ../../layers/graphics/graphicUtils ../../support/buffer/glUtil ../../support/buffer/InterleavedLayout ../lib/DefaultVertexAttributeLocations ../lib/gl-matrix ../lib/GLMaterialTexture ../lib/Material ../lib/RenderSlot ../lib/ShaderVariations ../lib/Util ./internal/MaterialUtil ../../../webgl/Program ../../../webgl/Util".split(" "),function(D,ga,m,S,T,E,F,k,q,r,U,z,t,V,h,n,u){function v(d,b){var a=d.gl;
(b.cullFace?"none"===b.cullFace:b.transparent)?d.setFaceCullingEnabled(!1):(d.setFaceCullingEnabled(!0),"front"===b.cullFace&&d.setCullFace(a.FRONT))}function w(d,b){var a=d.gl;(b.cullFace?"none"===b.cullFace:b.transparent)?d.setFaceCullingEnabled(!0):(d.setFaceCullingEnabled(!1),"front"===b.cullFace&&d.setCullFace(a.BACK))}function p(d,b){return d?z.TRANSPARENT_MATERIAL:b?z.STENCIL_MATERIAL:z.OPAQUE_MATERIAL}function x(d,b){var a=b.vvSizeEnabled;b.vvSizeEnabled?(d.setUniform3fv("vvSizeMinSize",b.vvSizeMinSize),
d.setUniform3fv("vvSizeMaxSize",b.vvSizeMaxSize),d.setUniform3fv("vvSizeOffset",b.vvSizeOffset),d.setUniform3fv("vvSizeFactor",b.vvSizeFactor)):a&&d.setUniform3fv("vvSizeValue",b.vvSizeValue);a&&(d.setUniform3fv("vvSymbolAnchor",b.vvSymbolAnchor),T.computeObjectRotation(b.vvSymbolRotation[2],b.vvSymbolRotation[0],b.vvSymbolRotation[1],A.identity(G)),d.setUniformMatrix3fv("vvSymbolRotation",A.toMat3(G,W)));b.vvColorEnabled&&(d.setUniform1fv("vvColorValues",b.vvColorValues),d.setUniform4fv("vvColorColors",
b.vvColorColors))}function y(d,b){d.vvSizeEnabled=b.vvSizeEnabled;d.vvSizeMinSize=b.vvSizeMinSize;d.vvSizeMaxSize=b.vvSizeMaxSize;d.vvSizeOffset=b.vvSizeOffset;d.vvSizeFactor=b.vvSizeFactor;d.vvSizeValue=b.vvSizeValue;d.vvSymbolAnchor=b.vvSymbolAnchor;d.vvSymbolRotation=b.vvSymbolRotation}var f=q.vec3d,H=q.vec4d,I=q.mat3d,A=q.mat4d,J=V.assert;D=function(d){function b(a,c){c=d.call(this,c)||this;c.supportsEdges=!0;c.params=h.copyParameters(a,X);c.instanced=!!a.instanced;c.vertexBufferLayout=b.getVertexBufferLayout(c.params);
c.instanceBufferLayout=c.instanced?b.getInstanceBufferLayout(c.params):null;return c}m(b,d);b.prototype.isVisible=function(){var a=this.params;if(!d.prototype.isVisible.call(this)||0===a.layerOpacity)return!1;var c=l&&a.instanced,e=a.vertexColors,g=a.symbolColors,c=!!c&&-1<c.indexOf("color"),b=a.vvColorEnabled,h="replace"===a.colorMixMode,f=0<a.opacity,a=a.externalColor&&0<a.externalColor[3];return e&&(c||b||g)?h?!0:f:e?h?a:f:c||b||g?h?!0:f:h?a:f};b.prototype.getParams=function(){return this.params};
b.prototype.getParameterValues=function(){var a=this.params;return{textureId:a.textureId,ambient:a.ambient,diffuse:a.diffuse,specular:a.specular,externalColor:a.externalColor,colorMixMode:a.colorMixMode,opacity:a.opacity,layerOpacity:a.layerOpacity,transparent:a.transparent,polygonOffset:a.polygonOffset,atlasRegions:a.atlasRegions,flipV:a.flipV,doubleSided:a.doubleSided,doubleSidedType:a.doubleSidedType,cullFace:a.cullFace,writeStencil:a.writeStencil,receiveSSAO:a.receiveSSAO,castShadows:a.castShadows,
verticalOffset:a.verticalOffset,screenSizePerspective:a.screenSizePerspective,vvSizeEnabled:a.vvSizeEnabled,vvSizeMinSize:a.vvSizeMinSize,vvSizeMaxSize:a.vvSizeMaxSize,vvSizeOffset:a.vvSizeOffset,vvSizeFactor:a.vvSizeFactor,vvSizeValue:a.vvSizeValue,vvColorEnabled:a.vvColorEnabled,vvColorValues:a.vvColorValues,vvColorColors:a.vvColorColors,compressedNormals:a.compressedNormals,groundNormalShading:a.groundNormalShading,vvSymbolAnchor:a.vvSymbolAnchor,vvSymbolRotation:a.vvSymbolRotation}};b.prototype.setParameterValues=
function(a){var c=this.params,e;for(e in a)"textureId"===e&&J(c.textureId,"Can only change texture of material that already has a texture"),"castShadows"===e&&J(a.castShadows===c.castShadows,"Can not change shadow casting behavior."),c[e]=a[e];this.notifyDirty("matChanged")};b.prototype.getOutputAmount=function(a){var c=u.getStride(this.vertexBufferLayout)/4;return a*c};b.prototype.getVertexBufferLayout=function(){return this.vertexBufferLayout};b.prototype.getInstanceBufferLayout=function(){return this.instanceBufferLayout};
b.prototype.fillInterleaved=function(a,c,e,b,d,f,k){h.fillInterleaved(a,c,e,b,this.vertexBufferLayout,d,f,k)};b.prototype.intersect=function(a,c,e,b,d,k,n,l){if(null!==this.params.verticalOffset){l=b.camera;f.set3(e[12],e[13],e[14],B);var g=f.subtract(B,l.eye,Y),K=f.length(g),m=f.scale(g,1/K),p=null,g=null;switch(b.viewingMode){case "global":g=f.normalize(B,L);break;case "local":g=f.set(Z,L)}this.params.screenSizePerspective&&(p=f.dot(g,m));l=h.verticalOffsetAtDistance(l,K,this.params.verticalOffset,
p,this.params.screenSizePerspective);f.scale(g,l);I.multiplyVec3(b.transformInverseRotation,g,C);d=f.subtract(d,C,aa);k=f.subtract(k,C,ba)}h.intersectTriangleGeometry(a,c,e,b,d,k,n)};b.prototype.getGLMaterials=function(){return{color:ca,depthShadowMap:this.params.castShadows?da:null,normal:ea,depth:M,highlight:fa}};b.prototype.getAllTextureIds=function(){var a=this.params,c=[];a.textureId&&c.push(a.textureId);return c};b.loadShaders=function(a,c,e){a._parse(S);l=null!==e.capabilities.instancing;var b=
new t("phong",["vsPhong","fsPhong"],null,c,a,e);b.addNaryShaderSnippetSuffix([{value:"none",programNameSuffix:"",shaderSnippetSuffix:""},{value:"Textured"},{value:"AtlasTextured"}]);b.addDefine("Color","VERTEXCOLORS");b.addDefine("symbolColor","SYMBOLVERTEXCOLORS");b.addDefine("FlipV","FLIPV");b.addDefine("DoubleSided","DOUBLESIDED");b.addDefine("WindingOrderDoubleSided","WINDINGORDERDOUBLESIDED");b.addDefine("Instanced","INSTANCED");b.addDefine("InstColor","INSTANCEDCOLOR");b.addDefine("ReceiveShadows",
"RECEIVE_SHADOWS");b.addDefine("ReceiveSSAO","RECEIVE_SSAO");b.addDefine("vvSize","VV_SIZE");b.addDefine("vvColor","VV_COLOR");b.addDefine("VerticalOffset","VERTICAL_OFFSET");b.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE");b.addDefine("groundNormalShading","GROUND_NORMAL_SHADING");b.addDefine("compressedNormals","COMPRESSED_NORMALS");b.addDefine("componentColor","COMPONENTCOLORS");c.addShaderVariations(N,b);b=new t("depth",["vsDepth","fsDepth"],null,c,a,e);b.addNaryShaderSnippetSuffix([{value:"none",
programNameSuffix:"",shaderSnippetSuffix:""},{value:"Textured"},{value:"AtlasTextured"}]);b.addDefine("FlipV","FLIPV");b.addDefine("Instanced","INSTANCED");b.addDefine("ShadowMap","BIAS_SHADOWMAP");b.addDefine("vvSize","VV_SIZE");b.addDefine("VerticalOffset","VERTICAL_OFFSET");b.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE");c.addShaderVariations(O,b);b=new t("normal",["vsNormal","fsNormal"],null,c,a,e);b.addNaryShaderSnippetSuffix([{value:"none",programNameSuffix:"",shaderSnippetSuffix:""},
{value:"Textured"},{value:"AtlasTextured"}]);b.addDefine("FlipV","FLIPV");b.addDefine("Instanced","INSTANCED");b.addDefine("vvSize","VV_SIZE");b.addDefine("VerticalOffset","VERTICAL_OFFSET");b.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE");b.addDefine("compressedNormals","COMPRESSED_NORMALS");c.addShaderVariations(P,b);b=new t("highlight",["vsHighlight","fsHighlight"],null,c,a,e);b.addNaryShaderSnippetSuffix([{value:"none",programNameSuffix:"",shaderSnippetSuffix:""},{value:"Textured"},
{value:"AtlasTextured"}]);b.addDefine("FlipV","FLIPV");b.addDefine("Instanced","INSTANCED");b.addDefine("vvSize","VV_SIZE");b.addDefine("VerticalOffset","VERTICAL_OFFSET");b.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE");c.addShaderVariations(Q,b);var b=new n(e,a.vsDepth,a.fsDepth,k.Default3D,["BIAS_SHADOWMAP 1"]),d=new n(e,a.vsDepthTextured,a.fsDepthTextured,k.Default3D,["BIAS_SHADOWMAP 1"]),h=new n(e,a.vsDepth,a.fsDepth,k.Default3D),f=new n(e,a.vsDepthTextured,a.fsDepthTextured,k.Default3D),
m=new n(e,a.vsNormal,a.fsNormal,k.Default3D),p=new n(e,a.vsNormalTextured,a.fsNormalTextured,k.Default3D),q=new n(e,a.vsHighlight,a.fsHighlight,k.Default3D);a=new n(e,a.vsHighlightTextured,a.fsHighlightTextured,k.Default3D);c.add("depthShadowMap",b);c.add("depthTexturedShadowMap",d);c.add("depth",h);c.add("depthTextured",f);c.add("normal",m);c.add("normalTextured",p);c.add("highlight",q);c.add("highlightTextured",a)};b.getVertexBufferLayout=function(a){var c=F.newLayout().vec3f("position");a.groundNormalShading||
(c=a.compressedNormals?c.vec2i16("normalCompressed",{glNormalized:!0}):c.vec3f("normal"));a.textureId&&(c=c.vec2f("uv0"),a.atlasRegions&&(c=c.vec4u16("region")));a.vertexColors&&(c=c.vec4u8("color"));a.symbolColors&&(c=c.vec4u8("symbolColor"));a.componentIndices&&(c=c.u16("componentIndex").u16("_padding",{glPadding:!0}));return E.glLayout(c)};b.getInstanceBufferLayout=function(a){var c=F.newLayout().mat4f("model").mat4f("modelNormal");a.instanced&&-1<a.instanced.indexOf("color")&&(c=c.vec4f("instanceColor"));
a.instanced&&-1<a.instanced.indexOf("featureAttribute")&&(c=c.vec4f("instanceFeatureAttribute"));return E.glLayout(c,1)};return b}(U);var ca=function(d){function b(a,c,b){c=d.call(this,a,c,b,a.getParams().textureId)||this;c.programs=[[null,null],[null,null]];c.params=h.copyParameters(a.getParams());c.slot=p(c.params.transparent,c.params.writeStencil);a=c.params;c.texturing=a.textureId?a.atlasRegions?"AtlasTextured":"Textured":"none";b=l&&a.instanced;c.instanced=!!b;c.instancedColor=!!b&&-1<b.indexOf("color");
c.pseudoInstancedColor=!l&&a.instanced&&-1<a.instanced.indexOf("color");c._loadPrograms();return c}m(b,d);b.prototype._loadPrograms=function(){this.programs[0][0]=this._loadProgram(!1,!1);this.programs[1][0]=this._loadProgram(!0,!1);this.params.receiveSSAO?(this.programs[0][1]=this._loadProgram(!1,!0),this.programs[1][1]=this._loadProgram(!0,!0),this.allPrograms=this.programs[0].concat(this.programs[1])):(this.programs[0][1]=this.programs[0][0],this.programs[1][1]=this.programs[1][0],this.allPrograms=
[this.programs[0][0],this.programs[1][0]])};b.prototype._loadProgram=function(a,c){var b=this.params;return this.programRep.getShaderVariationsProgram(N,[this.texturing,b.vertexColors,b.symbolColors,b.flipV,b.doubleSided&&"normal"===b.doubleSidedType,b.doubleSided&&"winding-order"===b.doubleSidedType,!!this.instanced,this.instancedColor,a,c,b.vvSizeEnabled,b.vvColorEnabled,null!==b.verticalOffset,null!==b.screenSizePerspective,b.groundNormalShading,b.compressedNormals,null!=b.componentColorBuffer])};
b.prototype.beginSlot=function(a){return a===this.slot};b.prototype.getProgram=function(){return this.program||this.programs[0][0]};b.prototype.getPrograms=function(){return this.allPrograms};b.prototype.updateParameters=function(){var a=this.material.getParams(),c=this.params;c.ambient=a.ambient;c.diffuse=a.diffuse;c.specular=a.specular;c.externalColor=a.externalColor;c.colorMixMode=a.colorMixMode;c.opacity=a.opacity;c.layerOpacity=a.layerOpacity;c.polygonOffset=a.polygonOffset;c.flipV=a.flipV;c.doubleSided=
a.doubleSided;c.doubleSidedType=a.doubleSidedType;c.cullFace=a.cullFace;c.receiveSSAO=a.receiveSSAO;c.castShadows=a.castShadows;c.verticalOffset=a.verticalOffset;c.screenSizePerspective=a.screenSizePerspective;y(c,a);c.vvColorEnabled=a.vvColorEnabled;c.vvColorValues=a.vvColorValues;c.vvColorColors=a.vvColorColors;c.transparent!==a.transparent&&(this.slot=p(a.transparent,a.writeStencil),c.transparent=a.transparent);c.compressedNormals=a.compressedNormals;c.groundNormalShading=a.groundNormalShading;
this.updateTexture(a.textureId);a.atlasRegions&&(c.atlasRegions=a.atlasRegions);c.blendModeOneOne=a.blendModeOneOne;c.inverseWindingOrder=a.inverseWindingOrder;this._loadPrograms()};b.prototype.bind=function(a,c){var b=a.gl,g=this.params,d=this.program=this.programs[c.shadowMappingEnabled?1:0][c.ssaoEnabled?1:0];a.bindProgram(d);d.setUniform3fv("ambient",g.ambient);d.setUniform3fv("diffuse",g.diffuse);d.setUniform3fv("specular",g.specular);d.setUniform4fv("externalColor",g.externalColor);d.setUniform1i("colorMixMode",
h.colorMixModes[g.colorMixMode]);d.setUniform1f("opacity",g.opacity);d.setUniform1f("layerOpacity",g.layerOpacity);h.bindVerticalOffset(g.verticalOffset,c,d);h.bindScreenSizePerspective(g.screenSizePerspective,d);x(d,g);this.bindTexture(a,d);"AtlasTextured"===this.texturing&&this.bindTextureSize(a,d);a.setBlendFunctionSeparate(b.SRC_ALPHA,b.ONE_MINUS_SRC_ALPHA,b.ONE,b.ONE_MINUS_SRC_ALPHA);g.inverseWindingOrder&&a.setFrontFace(b.CW);g.transparent?(a.setBlendingEnabled(!0),g.blendModeOneOne?(a.setBlendFunction(b.ONE,
b.ONE),a.setDepthWriteEnabled(!1)):a.setBlendFunctionSeparate(b.SRC_ALPHA,b.ONE_MINUS_SRC_ALPHA,b.ONE,b.ONE_MINUS_SRC_ALPHA)):a.setBlendingEnabled(!1);g.polygonOffset&&(a.setPolygonOffsetFillEnabled(!0),a.setPolygonOffset(2,2));v(a,g);a.setDepthTestEnabled(!0);g.componentIndices&&g.componentColorBuffer&&(g.componentColorBuffer.updateTexture(),g.componentColorBuffer.bind(d,{tex:"uComponentColorTex",invDim:"uComponentColorTexInvDim",unit:1}))};b.prototype.release=function(a,c){c=a.gl;a.setPolygonOffsetFillEnabled(!1);
w(a,this.params);a.setBlendingEnabled(!1);a.setBlendFunctionSeparate(c.SRC_ALPHA,c.ONE_MINUS_SRC_ALPHA,c.ONE,c.ONE_MINUS_SRC_ALPHA);a.setDepthWriteEnabled(!0);a.setFrontFace(c.CCW)};b.prototype.bindView=function(a,c){a=this.program=this.programs[c.shadowMappingEnabled?1:0][c.ssaoEnabled?1:0];var b=c.origin;h.bindView(b,c.view,a);h.bindCamPos(b,c.viewInvTransp,a);c.shadowMappingEnabled&&c.shadowMap.bindView(a,b)};b.prototype.bindInstance=function(a,c){a=this.program;a.setUniformMatrix4fv("model",c.transformation);
a.setUniformMatrix4fv("modelNormal",c.transformationNormal);c.instanceParameters&&this.pseudoInstancedColor&&(c=c.instanceParameters.color)&&(H.multiply(c,this.params.externalColor,R),a.setUniform4fv("externalColor",R))};b.prototype.getDrawMode=function(a){return a.gl.TRIANGLES};return b}(r),M=function(d){function b(a,c,b,g){void 0===g&&(g=!1);b=d.call(this,a,c,b,a.getParams().textureId)||this;b.params=h.copyParameters(a.getParams());b.instanced=l&&!!b.params.instanced;b.texturing=u.hasAttribute(a.getVertexBufferLayout(),
"uv0")?"Textured":"none";b.program=c.getShaderVariationsProgram(O,[b.texturing,b.params.flipV,b.instanced,g,b.params.vvSizeEnabled,null!==b.params.verticalOffset,null!==b.params.screenSizePerspective]);b.slot=p(b.params.transparent,b.params.writeStencil);return b}m(b,d);b.prototype.beginSlot=function(a){return a===this.slot};b.prototype.getProgram=function(){return this.program};b.prototype.updateParameters=function(){var a=this.material.getParams(),b=this.params;b.cullFace=a.cullFace;b.inverseWindingOrder=
a.inverseWindingOrder;b.flipV=a.flipV;y(b,a);this.updateTexture(a.textureId)};b.prototype.bind=function(a,b){var c=a.gl,d=this.program,f=this.params;a.bindProgram(d);d.setUniform2fv("nearFar",b.nearFar);f.inverseWindingOrder&&a.setFrontFace(c.CW);h.bindVerticalOffset(f.verticalOffset,b,d);h.bindScreenSizePerspective(f.screenSizePerspective,d);x(d,f);this.bindTexture(a,d);v(a,f);a.setDepthTestEnabled(!0)};b.prototype.release=function(a){var b=a.gl,e=this.params;w(a,e);e.inverseWindingOrder&&a.setFrontFace(b.CCW)};
b.prototype.bindView=function(a,b){a=this.program;var c=this.params;h.bindView(b.origin,b.view,a);c.screenSizePerspective&&h.bindCamPos(b.origin,b.viewInvTransp,a)};b.prototype.bindInstance=function(a,b){this.program.setUniformMatrix4fv("model",b.transformation)};b.prototype.getDrawMode=function(a){return a.gl.TRIANGLES};return b}(r),da=function(d){function b(a,b,e){return d.call(this,a,b,e,!0)||this}m(b,d);return b}(M),ea=function(d){function b(a,b,e,g){void 0===g&&(g=!1);e=d.call(this,a,b,e,a.getParams().textureId)||
this;e.params=h.copyParameters(a.getParams());e.instanced=l&&!!e.params.instanced;e.texturing=u.hasAttribute(a.getVertexBufferLayout(),"uv0")?"Textured":"none";e.program=b.getShaderVariationsProgram(P,[e.texturing,e.params.flipV,e.instanced,e.params.vvSizeEnabled,null!==e.params.verticalOffset,null!==e.params.screenSizePerspective,e.params.compressedNormals]);e.slot=p(e.params.transparent,e.params.writeStencil);return e}m(b,d);b.prototype.beginSlot=function(a){return a===this.slot};b.prototype.getProgram=
function(){return this.program};b.prototype.updateParameters=function(){var a=this.material.getParams(),b=this.params;b.cullFace=a.cullFace;b.inverseWindingOrder=a.inverseWindingOrder;b.flipV=a.flipV;y(b,a);this.updateTexture(a.textureId)};b.prototype.bind=function(a,b){var c=a.gl,d=this.program,f=this.params;a.bindProgram(d);this.bindTexture(a,d);d.setUniformMatrix4fv("viewNormal",b.viewInvTransp);h.bindVerticalOffset(f.verticalOffset,b,d);h.bindScreenSizePerspective(f.screenSizePerspective,d);x(d,
f);v(a,f);f.inverseWindingOrder&&a.setFrontFace(c.CW);a.setDepthTestEnabled(!0)};b.prototype.release=function(a){var b=a.gl,d=this.params;w(a,d);d.inverseWindingOrder&&a.setFrontFace(b.CCW)};b.prototype.bindView=function(a,b){a=this.program;var c=this.params;h.bindView(b.origin,b.view,a);c.screenSizePerspective&&h.bindCamPos(b.origin,b.viewInvTransp,a)};b.prototype.bindInstance=function(a,b){a=this.program;a.setUniformMatrix4fv("model",b.transformation);a.setUniformMatrix4fv("modelNormal",b.transformationNormal)};
b.prototype.getDrawMode=function(a){return a.gl.TRIANGLES};return b}(r),fa=function(d){function b(a,b,e,g){void 0===g&&(g=!1);e=d.call(this,a,b,e,a.getParams().textureId)||this;e.params=h.copyParameters(a.getParams());e.instanced=l&&!!e.params.instanced;e.texturing=u.hasAttribute(a.getVertexBufferLayout(),"uv0")?"Textured":"none";e.program=b.getShaderVariationsProgram(Q,[e.texturing,e.params.flipV,e.instanced,e.params.vvSizeEnabled,null!==e.params.verticalOffset,null!==e.params.screenSizePerspective]);
e.slot=p(e.params.transparent,e.params.writeStencil);return e}m(b,d);b.prototype.beginSlot=function(a){return a===this.slot};b.prototype.getProgram=function(){return this.program};b.prototype.updateParameters=function(){var a=this.material.getParams(),b=this.params;b.cullFace=a.cullFace;b.inverseWindingOrder=a.inverseWindingOrder;b.flipV=a.flipV;y(b,a);this.updateTexture(a.textureId)};b.prototype.bind=function(a,b){var c=a.gl,d=this.program,f=this.params;a.bindProgram(d);this.bindTexture(a,d);h.bindVerticalOffset(f.verticalOffset,
b,d);h.bindScreenSizePerspective(f.screenSizePerspective,d);x(d,f);v(a,f);f.inverseWindingOrder&&a.setFrontFace(c.CW);a.setDepthTestEnabled(!0)};b.prototype.release=function(a){var b=a.gl,d=this.params;w(a,d);d.inverseWindingOrder&&a.setFrontFace(b.CW)};b.prototype.bindView=function(a,b){a=this.program;var c=this.params;h.bindView(b.origin,b.view,a);c.screenSizePerspective&&h.bindCamPos(b.origin,b.viewInvTransp,a)};b.prototype.bindInstance=function(a,b){a=this.program;a.setUniformMatrix4fv("model",
b.transformation);a.setUniformMatrix4fv("modelNormal",b.transformationNormal)};b.prototype.getDrawMode=function(a){return a.gl.TRIANGLES};return b}(r),X={textureId:void 0,ambient:[.2,.2,.2],diffuse:[.8,.8,.8],specular:[0,0,0],externalColor:[1,1,1,1],colorMixMode:"multiply",opacity:1,layerOpacity:1,blendModeOneOne:!1,inverseWindingOrder:!1,vertexColors:!1,symbolColors:!1,componentIndices:!1,componentColorBuffer:null,flipV:!1,doubleSided:!1,doubleSidedType:"normal",cullFace:void 0,instanced:void 0,
compressedNormals:!1,groundNormalShading:!1,writeStencil:!1,receiveSSAO:!0,castShadows:!0,verticalOffset:null,screenSizePerspective:null,vvSizeEnabled:!1,vvSizeMinSize:[1,1,1],vvSizeMaxSize:[100,100,100],vvSizeOffset:[0,0,0],vvSizeFactor:[1,1,1],vvSizeValue:[1,1,1],vvColorEnabled:!1,vvColorValues:[0,0,0,0,0,0,0,0],vvColorColors:[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],vvSymbolAnchor:[0,0,0],vvSymbolRotation:[0,0,0],transparent:!1,polygonOffset:!1,atlasRegions:!1},l,N="material",
O="material-depth",P="material-normal",Q="material-highlight",R=H.create(),W=I.create(),G=A.create(),aa=f.create(),ba=f.create(),Z=f.createFrom(0,0,1),L=f.create(),C=f.create(),B=f.create(),Y=f.create();return D});