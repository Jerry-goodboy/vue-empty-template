// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.7/esri/copyright.txt for details.
//>>built
require({cache:{"url:esri/views/3d/webgl-engine/lib/edgeRendering/RibbonEdgeRenderer.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\r\n\r\n\x3csnippets\x3e\r\n\r\n\x3csnippet name\x3d"vsRibbonEdgeSketch"\x3e\x3c![CDATA[\r\n#if defined(SKETCH) || defined(UBER)\r\n\r\nuniform vec2 uStrokesTextureScale;\r\nuniform float uStrokesLog2Resolution;\r\nuniform float uStrokeVariants;\r\n\r\nvarying vec2 vStrokeUV;\r\nvarying float vLineIndex;\r\n\r\n  void calculateStyleOutputsSketch(float lineLength, UnpackedAttributes unpackedAttributes) {\r\n    vec2 sidenessNorm \x3d unpackedAttributes.sidenessNorm;\r\n\r\n    float lineIndex \x3d clamp(ceil(log2(lineLength)), 0.0, uStrokesLog2Resolution);\r\n\r\n    vStrokeUV \x3d vec2(exp2(lineIndex) * sidenessNorm.y, lineIndex * uStrokeVariants + variantStroke + 0.5) * uStrokesTextureScale;\r\n    vStrokeUV.x +\x3d variantOffset;\r\n\r\n    vLineIndex \x3d lineIndex;\r\n  }\r\n\r\n#endif /* SKETCH || UBER */\r\n\r\n#ifdef SKETCH\r\n\r\n  void calculateStyleOutputs(vec4 viewPosV0, vec4 viewPosV1, vec4 worldPosV0, vec4 worldPosV1, vec4 projPos, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\r\n    calculateStyleOutputsSketch(vLineLengthPixels, unpackedAttributes);\r\n  }\r\n\r\n#endif /* SKETCH */\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsRibbonEdgeEmissiveLighting"\x3e\x3c![CDATA[\r\n\r\n#if defined(EMISSIVE_LIGHTING) || defined(UBER)\r\n\r\n  void calculateStyleOutputsEmissive(vec4 viewPosV0, vec4 viewPosV1, vec4 worldPosV0, vec4 worldPosV1, vec4 projPos, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\r\n  }\r\n#endif /* EMISSIVE_LIGHTING || UBER */\r\n\r\n#ifdef EMISSIVE_LIGHTING\r\n\r\n  void calculateStyleOutputs(vec4 viewPosV0, vec4 viewPosV1, vec4 worldPosV0, vec4 worldPosV1, vec4 projPos, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\r\n    calculateStyleOutputsEmissive(viewPosV0, viewPosV1, worldPosV0, worldPosV1, projPos, worldNormal, unpackedAttributes);\r\n  }\r\n\r\n#endif /* EMISSIVE_LIGHTING */\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsRibbonEdgeUberLighting"\x3e\r\n\x3c![CDATA[\r\n\r\n#ifdef UBER\r\n\r\n  varying float vType;\r\n\r\n  void calculateStyleOutputs(vec4 viewPosV0, vec4 viewPosV1, vec4 worldPosV0, vec4 worldPosV1, vec4 projPos, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\r\n    vType \x3d unpackedAttributes.type;\r\n\r\n    if (unpackedAttributes.type \x3d\x3d 0.0) {\r\n      calculateStyleOutputsEmissive(viewPosV0, viewPosV1, worldPosV0, worldPosV1, projPos, worldNormal, unpackedAttributes);\r\n    }\r\n    else {\r\n      calculateStyleOutputsSketch(vLineLengthPixels, unpackedAttributes);\r\n    }\r\n  }\r\n\r\n#endif /* UBER */\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsRibbonEdgeLineAmplitudeRegular"\x3e\x3c![CDATA[\r\n\r\n#if defined(UBER) || !defined(SKETCH)\r\n\r\n  float calculateLineAmplitudeRegular() {\r\n    return 0.0;\r\n  }\r\n\r\n#endif /* UBER || !SKETCH */\r\n\r\n#if !defined(UBER) \x26\x26 !defined(SKETCH)\r\n\r\n  float calculateLineAmplitude(UnpackedAttributes unpackedAttributes) {\r\n    return calculateLineAmplitudeRegular();\r\n  }\r\n\r\n#endif /* !UBER \x26\x26 !SKETCH */\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsRibbonEdgeLineAmplitudeSketch"\x3e\x3c![CDATA[\r\n\r\n#if defined(UBER) || defined(SKETCH)\r\n\r\n  uniform float uStrokesAmplitude;\r\n\r\n  float calculateLineAmplitudeSketch() {\r\n    return uStrokesAmplitude;\r\n  }\r\n\r\n#endif /* UBER || SKETCH */\r\n\r\n#ifdef SKETCH\r\n\r\n  float calculateLineAmplitude(UnpackedAttributes unpackedAttributes) {\r\n    return calculateLineAmplitudeSketch();\r\n  }\r\n\r\n#endif /* SKETCH */\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsRibbonEdgeLineAmplitudeUber"\x3e\x3c![CDATA[\r\n\r\n#ifdef UBER\r\n\r\n  float calculateLineAmplitude(UnpackedAttributes unpackedAttributes) {\r\n    float type \x3d unpackedAttributes.type;\r\n\r\n    if (type \x3c\x3d 0.0) {\r\n      return calculateLineAmplitudeSketch();\r\n    }\r\n    else {\r\n      return calculateLineAmplitudeRegular();\r\n    }\r\n  }\r\n\r\n#endif /* UBER */\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsRibbonEdge"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n  // Transformations\r\n  uniform mat4 uProj;\r\n  uniform mat4 uView;\r\n  uniform mat4 uModel;\r\n  uniform vec3 uCameraPosition;\r\n\r\n  // Line configuration\r\n\r\n#ifndef UBER\r\n\r\n  uniform int uLineWidth;\r\n  uniform int uExtensionLength;\r\n\r\n#endif\r\n\r\n  // Conversion constants\r\n  uniform vec2 uPixelToNDC;\r\n  uniform vec2 uNDCToPixel;\r\n\r\n  // Inputs\r\n  attribute vec3 position0;\r\n  attribute vec3 position1;\r\n  attribute float variantOffset;\r\n  attribute float variantStroke;\r\n  attribute float variantExtension;\r\n\r\n#ifdef SILHOUETTE\r\n\r\n  attribute vec3 normalA;\r\n  attribute vec3 normalB;\r\n\r\n#else /* SILHOUETTE */\r\n\r\n  attribute vec3 normal;\r\n\r\n#endif /* SILHOUETTE */\r\n\r\nattribute vec2 sidenessAtt;\r\nattribute vec2 packedAttributes;\r\n\r\nstruct UnpackedAttributes {\r\n  vec2 sideness;\r\n  vec2 sidenessNorm;\r\n  float lineWidthPixels;\r\n  float extensionLengthPixels;\r\n\r\n#ifdef UBER\r\n\r\n  float type;\r\n\r\n#endif\r\n};\r\n\r\n  // Output required to compute color\r\n  varying vec4 vColor;\r\n\r\n  // Output required to compute distance to line/caps\r\n  varying vec3 vPosition;\r\n  varying float vRadius;\r\n  varying float vLineLengthPixels;\r\n  varying float vSizeFalloffFactor;\r\n\r\n  $EdgeRendererUtils_adjustProjectedPosition\r\n\r\n  $vsRibbonEdgeEmissiveLighting\r\n  $vsRibbonEdgeSketch\r\n  $vsRibbonEdgeUberLighting\r\n\r\n  $vsRibbonEdgeLineAmplitudeRegular\r\n  $vsRibbonEdgeLineAmplitudeSketch\r\n  $vsRibbonEdgeLineAmplitudeUber\r\n\r\n  $EdgeRendererUtils_readComponentColor\r\n  $EdgeRendererUtils_distanceBasedPerspectiveFactor\r\n  $EdgeRendererUtils_worldNormal\r\n  $EdgeRendererUtils_extensionFalloff\r\n\r\n#ifdef SILHOUETTE\r\n\r\n  $EdgeRendererUtils_isSilhouetteEdge\r\n\r\n#endif /* SILHOUETTE */\r\n\r\n  vec4 calculateGeometricOutputs(vec4 viewPosV0, vec4 viewPosV1, vec4 worldPosV0, vec4 worldPosV1, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\r\n    vec2 sideness \x3d unpackedAttributes.sideness;\r\n    vec2 sidenessNorm \x3d unpackedAttributes.sidenessNorm;\r\n\r\n    vec4 viewPos \x3d mix(viewPosV0, viewPosV1, sidenessNorm.y);\r\n    vec4 projPosV0 \x3d uProj * viewPosV0;\r\n    vec4 projPosV1 \x3d uProj * viewPosV1;\r\n    vec4 projPos \x3d uProj * viewPos;\r\n\r\n    vec3 screenSpaceLineNDC \x3d (projPosV1.xyz / projPosV1.w - projPosV0.xyz / projPosV0.w);\r\n    vec2 screenSpaceLinePixels \x3d screenSpaceLineNDC.xy * uNDCToPixel;\r\n    float lineLengthPixels \x3d length(screenSpaceLinePixels);\r\n\r\n    float dzPerPixel \x3d screenSpaceLineNDC.z / lineLengthPixels;\r\n    vec2 screenSpaceDirection \x3d screenSpaceLinePixels / lineLengthPixels;\r\n    vec2 perpendicularScreenSpaceDirection \x3d vec2(screenSpaceDirection.y, -screenSpaceDirection.x) * sideness.x;\r\n\r\n    float falloffFactor \x3d distanceBasedPerspectiveFactor(-viewPos.z);\r\n    float lineWidthPixels \x3d unpackedAttributes.lineWidthPixels * falloffFactor;\r\n\r\n    float extensionLengthPixels \x3d calculateExtensionLength(unpackedAttributes.extensionLengthPixels, lineLengthPixels) * falloffFactor;\r\n    float lineAmplitudePixels \x3d calculateLineAmplitude(unpackedAttributes);\r\n\r\n    vSizeFalloffFactor \x3d falloffFactor;\r\n\r\n    float lineWidthAndAmplitudePixels \x3d lineWidthPixels + lineAmplitudePixels + lineAmplitudePixels;\r\n    float extendedLineLengthPixels \x3d lineLengthPixels + extensionLengthPixels + extensionLengthPixels;\r\n\r\n#ifdef ANTIALIASING\r\n\r\n    const float aaPaddingPixels \x3d 1.0;\r\n\r\n    // Line size with padding\r\n    float halfAAPaddedLineWidthAndAmplitudePixels \x3d lineWidthAndAmplitudePixels * 0.5 + aaPaddingPixels;\r\n    float aaPaddedRoundedCapSizePixels \x3d lineWidthPixels * 0.5 + aaPaddingPixels;\r\n\r\n    // Line length with padding\r\n    float aaPaddedLineLengthPixels \x3d extendedLineLengthPixels + aaPaddingPixels + aaPaddingPixels;\r\n    float halfAAPaddedLineLengthPixels \x3d aaPaddedLineLengthPixels * 0.5;\r\n\r\n#else /* ANTIALIASING */\r\n\r\n    // Even if there is no AA, we still want to do proper \x3c1px rendering,\r\n    // so we effectively clamp the pixel sizes to minimum of 1px and compute\r\n    // coverage in the fragment shader\r\n    float halfAAPaddedLineWidthAndAmplitudePixels \x3d max(lineWidthAndAmplitudePixels, 1.0) * 0.5;\r\n    float aaPaddedRoundedCapSizePixels \x3d max(lineWidthPixels, 1.0) * 0.5;\r\n\r\n    float halfAAPaddedLineLengthPixels \x3d max(extendedLineLengthPixels, 1.0) * 0.5;\r\n\r\n#endif /* ANTIALIASING */\r\n\r\n    // Half line width in NDC including padding for anti aliasing\r\n    vec2 halfAAPaddedLineWidthAndAmplitudeNDC \x3d halfAAPaddedLineWidthAndAmplitudePixels * uPixelToNDC;\r\n    vec2 aaPaddedRoundedCapSizeNDC \x3d aaPaddedRoundedCapSizePixels * uPixelToNDC;\r\n    vec2 extensionLengthNDC \x3d extensionLengthPixels * uPixelToNDC;\r\n\r\n    // Compute screen space position of vertex, offsetting for line size and end caps\r\n    vec2 ndcOffset \x3d (\r\n        screenSpaceDirection * sideness.y * (aaPaddedRoundedCapSizeNDC + extensionLengthNDC)\r\n      + perpendicularScreenSpaceDirection * halfAAPaddedLineWidthAndAmplitudeNDC\r\n    );\r\n\r\n    projPos.xy +\x3d ndcOffset * projPos.w;\r\n    projPos.z +\x3d (dzPerPixel * (aaPaddedRoundedCapSizePixels + extensionLengthPixels)) * sideness.y * projPos.w;\r\n\r\n    projPos \x3d adjustProjectedPosition(projPos, worldNormal, 1.0 + max((lineWidthAndAmplitudePixels - 1.0) * 0.5, 0.0));\r\n\r\n    // Line length with end caps\r\n    float aaPaddedLineWithCapsLengthPixels \x3d extendedLineLengthPixels + aaPaddedRoundedCapSizePixels + aaPaddedRoundedCapSizePixels;\r\n\r\n    float pixelPositionAlongLine \x3d aaPaddedLineWithCapsLengthPixels * sidenessNorm.y - aaPaddedRoundedCapSizePixels;\r\n\r\n    // Position in pixels with origin at first vertex of line segment\r\n    vPosition \x3d vec3(\r\n      halfAAPaddedLineWidthAndAmplitudePixels * sideness.x,\r\n      pixelPositionAlongLine,\r\n      pixelPositionAlongLine / extendedLineLengthPixels\r\n    );\r\n\r\n    // The line width radius in pixels\r\n    vRadius \x3d lineWidthPixels * 0.5;\r\n    vLineLengthPixels \x3d extendedLineLengthPixels;\r\n\r\n#ifdef SILHOUETTE\r\n\r\n    gl_Position \x3d isSilhouetteEdge(viewPosV0) ? projPos : vec4(10, 10, 10, 1);\r\n\r\n#else /* SILHOUETTE */\r\n\r\n    gl_Position \x3d projPos;\r\n\r\n#endif /* SILHOUETTE */\r\n\r\n#ifdef UBER\r\n\r\n    if (unpackedAttributes.type \x3c\x3d 0.0 \x26\x26 lineLengthPixels \x3c\x3d 3.0) {\r\n      gl_Position \x3d vec4(10, 10, 10, 1);\r\n    }\r\n\r\n#elif defined(SKETCH)\r\n\r\n    if (lineLengthPixels \x3c\x3d 3.0) {\r\n      gl_Position \x3d vec4(10, 10, 10, 1);\r\n    }\r\n\r\n#endif\r\n\r\n    return projPos;\r\n  }\r\n\r\n  void calculateColorOutputs() {\r\n    vColor \x3d readComponentColor();\r\n  }\r\n\r\n#ifdef UBER\r\n\r\n#if __VERSION__ !\x3d 100\r\n#define SUPPORTS_BITWISE_OPERATIONS\r\n#endif\r\n\r\n#ifndef SUPPORTS_BITWISE_OPERATIONS\r\n\r\n  /**\r\n   * Returns whether the first bit in x is set (0 or 1) and shifts\r\n   * the input by one bit.\r\n   */\r\n  int isSetAndShift(inout int x) {\r\n    int isSet \x3d x - 2 * (x / 2);\r\n    x /\x3d 2;\r\n\r\n    return isSet;\r\n  }\r\n\r\n#endif /* SUPPORTS_BITWISE_OPERATIONS */\r\n\r\n  UnpackedAttributes unpackAttributes() {\r\n    int packedTypeAndLineWidth \x3d int(packedAttributes.x);\r\n    float extensionLengthPixels \x3d float(packedAttributes.y);\r\n\r\n#ifndef SUPPORTS_BITWISE_OPERATIONS\r\n\r\n    int type \x3d isSetAndShift(packedTypeAndLineWidth);\r\n    int lineWidthPixels \x3d packedTypeAndLineWidth;\r\n\r\n#else /* SUPPORTS_BITWISE_OPERATIONS */\r\n\r\n    int type \x3d (packedTypeAndLineWidth ) \x26 0x01;\r\n    int lineWidthPixels \x3d (packedTypeAndLineWidth \x3e\x3e 1) \x26 0xf;\r\n\r\n#endif /* SUPPORTS_BITWISE_OPERATIONS */\r\n\r\n    vec2 sidenessNorm \x3d sidenessAtt;\r\n    vec2 sideness \x3d sidenessNorm * 2.0 - 1.0;\r\n\r\n    float fType \x3d -float(type) + 0.5; // SOLID (\x3d0) needs to be \x3e 0.0, SKETCHY (\x3d1) needs to be \x3c\x3d 0;\r\n\r\n    if (fType \x3c\x3d 0.0) {\r\n      extensionLengthPixels *\x3d variantExtension * 2.0 - 1.0;\r\n    }\r\n\r\n    return UnpackedAttributes(sideness, sidenessNorm, float(lineWidthPixels), extensionLengthPixels, fType);\r\n  }\r\n\r\n#else /* UBER */\r\n\r\n  UnpackedAttributes unpackAttributes() {\r\n    vec2 sidenessNorm \x3d sidenessAtt;\r\n    vec2 sideness \x3d sidenessNorm * 2.0 - 1.0;\r\n    float extensionLengthPixels \x3d float(uExtensionLength);\r\n\r\n#ifdef SKETCH\r\n\r\n    extensionLengthPixels *\x3d variantExtension * 2.0 - 1.0;\r\n\r\n#endif /* SKETCH */\r\n\r\n    return UnpackedAttributes(sideness, sidenessNorm, float(uLineWidth), extensionLengthPixels);\r\n  }\r\n\r\n#endif /* UBER */\r\n\r\n  void main() {\r\n\r\n    UnpackedAttributes unpackedAttributes \x3d unpackAttributes();\r\n\r\n    vec4 worldPosV0 \x3d uModel * vec4(position0, 1.0);\r\n    vec4 worldPosV1 \x3d uModel * vec4(position1, 1.0);\r\n\r\n    vec4 viewPosV0 \x3d uView * worldPosV0;\r\n    vec4 viewPosV1 \x3d uView * worldPosV1;\r\n\r\n#ifdef SILHOUETTE\r\n\r\n    vec3 worldNormal \x3d silhouetteWorldNormal(normalA, normalB);\r\n\r\n#else /* SILHOUETTE */\r\n\r\n    vec3 worldNormal \x3d modelToWorldNormal(normal);\r\n\r\n#endif /* SILHOUETTE */\r\n\r\n    // General geometric computation for all types of edges\r\n    vec4 projPos \x3d calculateGeometricOutputs(viewPosV0, viewPosV1, worldPosV0, worldPosV1, worldNormal, unpackedAttributes);\r\n    calculateColorOutputs();\r\n\r\n    // Specific computation for different edge styles\r\n    calculateStyleOutputs(viewPosV0, viewPosV1, worldPosV0, worldPosV1, projPos, worldNormal, unpackedAttributes);\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsRibbonEdgeEmissiveLighting"\x3e\x3c![CDATA[\r\n\r\n#if defined(EMISSIVE_LIGHTING) || defined(UBER)\r\n\r\n  vec3 evaluateEdgeLightingEmissive(vec2 distance) {\r\n    return vColor.rgb;\r\n  }\r\n\r\n#endif /* EMISSIVE_LIGHTING || UBER */\r\n\r\n#ifdef EMISSIVE_LIGHTING\r\n\r\n  vec3 evaluateEdgeLighting(vec2 distance) {\r\n    return evaluateEdgeLightingEmissive(distance);\r\n  }\r\n\r\n#endif /* EMISSIVE_LIGHTING */\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsRibbonEdgeSketchLighting"\x3e\x3c![CDATA[\r\n\r\n#if defined(SKETCH) || defined(UBER)\r\n\r\n  vec3 evaluateEdgeLightingSketch(vec2 distance) {\r\n    return vColor.rgb;\r\n  }\r\n\r\n#endif /* SKETCH || UBER */\r\n\r\n#ifdef SKETCH\r\n\r\n  vec3 evaluateEdgeLighting(vec2 distance) {\r\n    return evaluateEdgeLightingSketch(distance);\r\n  }\r\n\r\n#endif /* SKETCH */\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsRibbonEdgeUberLighting"\x3e\x3c![CDATA[\r\n\r\n#ifdef UBER\r\n\r\n  varying float vType;\r\n\r\n  vec3 evaluateEdgeLighting(vec2 distance) {\r\n    if (vType \x3e 0.0) { // EMISSIVE\r\n      return evaluateEdgeLightingEmissive(distance);\r\n    }\r\n    else { // SKETCH\r\n      return evaluateEdgeLightingSketch(distance);\r\n    }\r\n  }\r\n\r\n#endif\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsRibbonEdgeLineOffsetSketch"\x3e\x3c![CDATA[\r\n\r\n$rgba2float\r\n\r\n#if defined(UBER) || defined(SKETCH)\r\n\r\n  uniform sampler2D uStrokesTexture;\r\n  uniform float uStrokesNormalizationScale;\r\n\r\n  varying vec2 vStrokeUV;\r\n\r\n  float calculateLineOffsetSketch() {\r\n    float offsetNorm \x3d rgba2float(texture2D(uStrokesTexture, vStrokeUV));\r\n    return (offsetNorm - 0.5) * uStrokesNormalizationScale;\r\n  }\r\n\r\n  float calculateLinePressureSketch() {\r\n\r\n#ifdef PRESSURE\r\n\r\n    return rgba2float(texture2D(uStrokesTexture, vStrokeUV + vec2(0, 0.5)));\r\n\r\n#else\r\n\r\n    return 1.0;\r\n\r\n#endif /* PRESSURE */\r\n\r\n  }\r\n\r\n#endif /* UBER || SKETCH */\r\n\r\n#ifdef SKETCH\r\n\r\n  float calculateLineOffset() {\r\n    return calculateLineOffsetSketch();\r\n  }\r\n\r\n  float calculateLinePressure() {\r\n    return calculateLinePressureSketch();\r\n  }\r\n\r\n#endif /* SKETCH */\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsRibbonEdgeLineOffsetRegular"\x3e\x3c![CDATA[\r\n\r\n#if defined(UBER) || !defined(SKETCH)\r\n\r\n  float calculateLineOffsetRegular() {\r\n    return 0.0;\r\n  }\r\n\r\n  float calculateLinePressureRegular() {\r\n    return 1.0;\r\n  }\r\n\r\n#endif /* UBER || !SKETCH */\r\n\r\n#if !defined(UBER) \x26\x26 !defined(SKETCH)\r\n\r\n  float calculateLineOffset() {\r\n    return calculateLineOffsetRegular();\r\n  }\r\n\r\n  float calculateLinePressure() {\r\n    return calculateLinePressureRegular();\r\n  }\r\n\r\n#endif /* !UBER || !SKETCH */\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsRibbonEdgeLineOffsetUber"\x3e\x3c![CDATA[\r\n\r\n#ifdef UBER\r\n\r\n  float calculateLineOffset() {\r\n    if (vType \x3c\x3d 0.0) {\r\n      return calculateLineOffsetSketch();\r\n    }\r\n    else {\r\n      return calculateLineOffsetRegular();\r\n    }\r\n  }\r\n\r\n  float calculateLinePressure() {\r\n\r\n#ifdef PRESSURE\r\n\r\n    if (vType \x3c\x3d 0.0) {\r\n      return calculateLinePressureSketch();\r\n    }\r\n    else {\r\n      return calculateLinePressureRegular();\r\n    }\r\n\r\n#else\r\n\r\n    return calculateLinePressureRegular();\r\n\r\n#endif /* PRESSURE */\r\n\r\n  }\r\n\r\n#endif /* UBER */\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsRibbonEdge"\x3e\x3c![CDATA[\r\n  $fsprecisionf\r\n\r\n  varying vec4 vColor;\r\n  varying float vRadius;\r\n  varying vec3 vPosition;\r\n  varying float vLineLengthPixels;\r\n  varying float vSizeFalloffFactor;\r\n  varying float vLineIndex;\r\n\r\n  // At which coverage threshold we discard a fragment completely\r\n  #define COVERAGE_TEST_THRESHOLD 0.01\r\n\r\n  $fsRibbonEdgeEmissiveLighting\r\n  $fsRibbonEdgeSketchLighting\r\n  $fsRibbonEdgeUberLighting\r\n\r\n  $fsRibbonEdgeLineOffsetRegular\r\n  $fsRibbonEdgeLineOffsetSketch\r\n  $fsRibbonEdgeLineOffsetUber\r\n\r\n  vec2 lineWithCapsDistance(float radius, vec2 position, float lineLength) {\r\n    float lineOffset \x3d calculateLineOffset();\r\n    float positionX \x3d position.x - lineOffset;\r\n\r\n    if (radius \x3c 1.0) {\r\n      // Handle this specifically for subpixel sizes:\r\n      // 1. Compute correct coverage (note coverage is computed by\r\n      //    0.5 - dist, so we make sure that that will lead to correct\r\n      //    subpixel coverage\r\n      // 2. Ignore rounded caps\r\n      float coverageX \x3d clamp(min(radius, positionX + 0.5) - max(-radius, positionX - 0.5), 0.0, 1.0);\r\n      float coverageY \x3d clamp(min(lineLength, position.y + 0.5) - max(0.0, position.y - 0.5), 0.0, 1.0);\r\n\r\n      float coverage \x3d min(coverageX, coverageY);\r\n\r\n      return vec2(0.5 - coverage, 0.0);\r\n    }\r\n    else {\r\n      // Between -radius -\x3e 0 for start cap, 0 for line, 0 -\x3e radius\r\n      float positionOnCap \x3d position.y - clamp(position.y, 0.0, lineLength);\r\n\r\n      vec2 lineToPosition \x3d vec2(positionX, positionOnCap);\r\n      return vec2(length(lineToPosition) - radius, positionOnCap / radius);\r\n    }\r\n  }\r\n\r\n  void main() {\r\n\r\n    float radius \x3d vRadius * calculateLinePressure();\r\n\r\n    vec2 distance \x3d lineWithCapsDistance(radius, vPosition.xy, vLineLengthPixels);\r\n    float coverage \x3d clamp(0.5 - distance.x, 0.0, 1.0);\r\n\r\n#ifdef ANTIALIASING\r\n\r\n    const float coverageLimit \x3d COVERAGE_TEST_THRESHOLD;\r\n\r\n#else /* ANTIALIASING */\r\n\r\n    // Use subpixel coverage computation when lines get subpixel widths\r\n    // so we still render them appropriately. Otherwise discard anything\r\n    // that is not fully within the line\r\n    float coverageLimit \x3d radius \x3c\x3d 0.5 ? COVERAGE_TEST_THRESHOLD : 0.75;\r\n\r\n#endif /* ANTIALIASING */\r\n\r\n    if (coverage \x3c coverageLimit) {\r\n      discard;\r\n    }\r\n\r\n    vec3 shadedColor \x3d evaluateEdgeLighting(distance);\r\n    float alpha \x3d vColor.a * coverage;\r\n\r\n    gl_FragColor \x3d vec4(shadedColor, alpha);\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3c/snippets\x3e\r\n'}});
define("require exports ../../../../../core/tsSupport/assignHelper ../../../../../core/tsSupport/extendsHelper dojo/text!./RibbonEdgeRenderer.xml ../../../lib/glMatrix ../../../support/mathUtils ../ShaderVariations ../Util ./EdgeRenderer ./ribbonEdgeBufferWriters".split(" "),function(e,k,l,q,r,m,t,u,v,f,g){Object.defineProperty(k,"__esModule",{value:!0});e=function(e){function c(a,b,d,n){a=e.call(this,a,b,c.getKey(d))||this;a.tmpViewToWorldNormalMatrix=m.mat3d.create();b=n.strokesTexture.variants;
a.settings=l({},p,c.materialSettings(d),n);d=l({},a.settings,{variants:b});a.edgeBufferWriters={default:{writer:new g.RibbonDefaultEdgeBufferWriter(d),glLayout:g.RibbonDefaultEdgeBufferWriter.glLayout},silhouette:{writer:new g.RibbonSilhouetteBufferWriter(d),glLayout:g.RibbonSilhouetteBufferWriter.glLayout}};a.createPrograms();return a}q(c,e);c.prototype.begin=function(a){};c.prototype.bindEdges=function(a,b){this.bind(this.programs.edge,a,b)};c.prototype.bindSilhouettes=function(a,b){this.bind(this.programs.silhouette,
a,b)};c.prototype.bind=function(a,b,d){this.rctx.bindProgram(a);a.setUniformMatrix4fv("uProj",b.proj);a.setUniform2f("uDepthBias",this.depthBiasXY,this.depthBiasZ);a.setUniform2f("uPixelToNDC",2/b.viewport[2],2/b.viewport[3]);a.setUniform2f("uNDCToPixel",b.viewport[2]/2,b.viewport[3]/2);a.setUniform1f("uDistanceFalloffFactor",d.distanceFalloffFactor);a.setUniform2f("uViewportDimInv",1/b.viewport[2],1/b.viewport[3])};c.prototype.renderEdges=function(a,b,d){this.render(this.programs.edge,a,a.edgeVAO,
b,d)};c.prototype.renderSilhouettes=function(a,b,d){this.render(this.programs.silhouette,a,a.silhouetteVAO,b,d)};c.prototype.numberOfPrimitives=function(a){return a.edgeLoD.lengths.length+(a.silhouetteLoD?a.silhouetteLoD.lengths.length:0)};c.prototype.render=function(a,b,d,c,e){d&&(this.setUniforms(a,b,c),a=this.rctx,a.bindVAO(d),a.capabilities.instancing.drawArraysInstanced(6,0,4,e))};c.prototype.setUniforms=function(a,b,d){b.componentBuffer.textureBuffer.bind(a,f.componentColorBindParameters);a.setUniformMatrix4fv("uView",
d.view);a.setUniformMatrix4fv("uModel",b.modelTransform);var c=d.viewInvTransp,e=m.mat4d.toMat3(c,this.tmpViewToWorldNormalMatrix);a.setUniform3f("uCameraPosition",c[3],c[7],c[11]);a.setUniformMatrix3fv("uViewToWorldNormalMatrix",e);this.settings.uber||(a.setUniform1i("uLineWidth",Math.round(b.material.size)),a.setUniform1i("uExtensionLength",Math.round(v.clamp(b.material.extensionLength,0,255))));(this.settings.uber||"sketch"===b.material.type)&&this.setSketchUniforms(a);a.setUniform1f("uWorldLineRadiusPerDistance",
Math.tan(d.fovY/2)/(d.viewport[3]/2));a.setUniform3fv("uLocalOrigin",b.origin.vec3);this.shadowsEnabled&&d.shadowMappingEnabled&&d.shadowMap.bindView(a,b.origin.vec3)};c.prototype.setSketchUniforms=function(a){var b=this.settings.strokesTexture,c=b.texture;this.rctx.bindTexture(c,0);a.setUniform1i("uStrokesTexture",0);a.setUniform2f("uStrokesTextureScale",1/c.descriptor.width,1/c.descriptor.height);a.setUniform1f("uStrokesLog2Resolution",t.log2(b.resolution));a.setUniform1f("uStrokesNormalizationScale",
b.normalizationScale);a.setUniform1f("uStrokesAmplitude",b.amplitude);a.setUniform1f("uStrokeVariants",b.variants)};Object.defineProperty(c.prototype,"shadowsEnabled",{get:function(){var a="smooth"===this.settings.lighting||"flat"===this.settings.lighting;return this.settings.receiveShadows&&(this.settings.uber||a)},enumerable:!0,configurable:!0});Object.defineProperty(c.prototype,"ssaoEnabled",{get:function(){var a="smooth"===this.settings.lighting||"flat"===this.settings.lighting;return this.settings.receiveSSAO&&
(this.settings.uber||a)},enumerable:!0,configurable:!0});c.prototype.end=function(a){};c.prototype.getDefines=function(a){return[a.silhouette,this.settings.antialiasing&&!!this.rctx.capabilities.blendMinMax,this.shadowsEnabled,this.ssaoEnabled,"smooth"===this.settings.lighting&&!this.settings.uber,"flat"===this.settings.lighting&&!this.settings.uber,"emissive"===this.settings.lighting&&!this.settings.uber,"sketch"===this.settings.lighting&&!this.settings.uber,this.settings.pressure,this.settings.uber]};
c.prototype.createPrograms=function(){this.addProgram("edge",this.programRepository.getShaderVariationsProgram(h,this.getDefines({silhouette:!1}),void 0,void 0,f.attributeLocations));this.addProgram("silhouette",this.programRepository.getShaderVariationsProgram(h,this.getDefines({silhouette:!0}),void 0,void 0,f.attributeLocations))};c.materialSettings=function(a){return a?"solid"===a.type?{lighting:"emissive"}:"sketch"===a.type?{lighting:"sketch"}:{lighting:"smooth"}:{}};c.loadShaders=function(a,
b,c){a.fsRibbonEdge||a._parse(r);b.getShaderVariations(h)||(a=new u("ribbonEdge",["vsRibbonEdge","fsRibbonEdge"],null,b,a,c),a.addDefine("Silhouette","SILHOUETTE"),a.addDefine("AntiAliasing","ANTIALIASING"),a.addDefine("ReceiveShadows","RECEIVE_SHADOWS"),a.addDefine("AmbientOcclusion","RECEIVE_SSAO"),a.addDefine("SmoothLighting","SMOOTH_LIGHTING"),a.addDefine("FlatLighting","FLAT_LIGHTING"),a.addDefine("EmissiveLighting","EMISSIVE_LIGHTING"),a.addDefine("Sketch","SKETCH"),a.addDefine("Pressure","PRESSURE"),
a.addDefine("Uber","UBER"),b.addShaderVariations(h,a))};c.getKey=function(a,b){if(!a)return"ribbon-uber";b=l({},p,this.materialSettings(a),b);return"ribbon-s:"+a.size+"-e:"+a.extensionLength+"-aa:"+b.antialiasing+"-sh:"+b.receiveShadows+"-l:"+b.lighting};return c}(f.EdgeRenderer);k.RibbonEdgeRenderer=e;var h="ribbon-edge-shader-variations",p={antialiasing:!0,lighting:"smooth",receiveShadows:!0,receiveSSAO:!0,uber:!0,pressure:!0,strokesTexture:null};k.default=e});